<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://songhanghang.github.io</id>
    <title>宋航</title>
    <updated>2019-08-22T07:45:50.027Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://songhanghang.github.io"/>
    <link rel="self" href="https://songhanghang.github.io/atom.xml"/>
    <subtitle>相信美好的事情即将发生</subtitle>
    <logo>https://songhanghang.github.io/images/avatar.png</logo>
    <icon>https://songhanghang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, 宋航</rights>
    <entry>
        <title type="html"><![CDATA[Comparator中Long Cast Int引发的血案]]></title>
        <id>https://songhanghang.github.io/post/comparator-zhong-long-cast-int-yin-fa-de-xie-an</id>
        <link href="https://songhanghang.github.io/post/comparator-zhong-long-cast-int-yin-fa-de-xie-an">
        </link>
        <updated>2019-08-21T12:30:52.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="先看代码">先看代码</h2>
<pre><code class="language-java">Collections.sort(list, new Comparator&lt;Long&gt;() {
                @Override
                public int compare(Long time1, Long time2) {
                    return (int) (time1 - time2);
                }
            });
</code></pre>
<p>这么短几行，看上去好像没什么问题？<br>
组内Code Review也未发现问题，但是上线一段时间后收到很多异常!</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="先看代码">先看代码</h2>
<pre><code class="language-java">Collections.sort(list, new Comparator&lt;Long&gt;() {
                @Override
                public int compare(Long time1, Long time2) {
                    return (int) (time1 - time2);
                }
            });
</code></pre>
<p>这么短几行，看上去好像没什么问题？<br>
组内Code Review也未发现问题，但是上线一段时间后收到很多异常!</p>
<!-- more --> 
<pre><code class="language-java">Caused by: java.lang.IllegalArgumentException: Comparison method violates its general contract!
    at java.util.TimSort.mergeHi(TimSort.java:899)
    at java.util.TimSort.mergeAt(TimSort.java:516)
    at java.util.TimSort.mergeCollapse(TimSort.java:441)
    at java.util.TimSort.sort(TimSort.java:245)
    at java.util.Arrays.sort(Arrays.java:1498)
    at java.util.ArrayList.sort(ArrayList.java:1470)
    at java.util.Collections.sort(Collections.java:201)
</code></pre>
<p>翻译过来<br>
比较方法违反了其总合同！！！</p>
<p>合同在哪？<br>
Comparator中compare有如下描述。</p>
<pre><code>**
     * Compares its two arguments for order.  Returns a negative integer,
     * zero, or a positive integer as the first argument is less than, equal
     * to, or greater than the second.&lt;p&gt;
     *
     * In the foregoing description, the notation
     * &lt;tt&gt;sgn(&lt;/tt&gt;&lt;i&gt;expression&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt; designates the mathematical
     * &lt;i&gt;signum&lt;/i&gt; function, which is defined to return one of &lt;tt&gt;-1&lt;/tt&gt;,
     * &lt;tt&gt;0&lt;/tt&gt;, or &lt;tt&gt;1&lt;/tt&gt; according to whether the value of
     * &lt;i&gt;expression&lt;/i&gt; is negative, zero or positive.&lt;p&gt;
     *
     * The implementor must ensure that &lt;tt&gt;sgn(compare(x, y)) ==
     * -sgn(compare(y, x))&lt;/tt&gt; for all &lt;tt&gt;x&lt;/tt&gt; and &lt;tt&gt;y&lt;/tt&gt;.  (This
     * implies that &lt;tt&gt;compare(x, y)&lt;/tt&gt; must throw an exception if and only
     * if &lt;tt&gt;compare(y, x)&lt;/tt&gt; throws an exception.)&lt;p&gt;
     *
     * The implementor must also ensure that the relation is transitive:
     * &lt;tt&gt;((compare(x, y)&amp;gt;0) &amp;amp;&amp;amp; (compare(y, z)&amp;gt;0))&lt;/tt&gt; implies
     * &lt;tt&gt;compare(x, z)&amp;gt;0&lt;/tt&gt;.&lt;p&gt;
     *
     * Finally, the implementor must ensure that &lt;tt&gt;compare(x, y)==0&lt;/tt&gt;
     * implies that &lt;tt&gt;sgn(compare(x, z))==sgn(compare(y, z))&lt;/tt&gt; for all
     * &lt;tt&gt;z&lt;/tt&gt;.&lt;p&gt;
     *
     * It is generally the case, but &lt;i&gt;not&lt;/i&gt; strictly required that
     * &lt;tt&gt;(compare(x, y)==0) == (x.equals(y))&lt;/tt&gt;.  Generally speaking,
     * any comparator that violates this condition should clearly indicate
     * this fact.  The recommended language is &quot;Note: this comparator
     * imposes orderings that are inconsistent with equals.&quot;
</code></pre>
<p>大致意思就是，你必须保证自反性，传递性，有序性。</p>
<ol>
<li>自反性：x，y 的比较结果和 y，x 的比较结果相反。</li>
<li>传递性：x&gt;y,y&gt;z,则 x&gt;z。</li>
<li>对称性：x=y,则 x,z 比较结果和 y，z 比较结果相同。</li>
</ol>
<p>那么我到底违反了那条合同了？<br>
唯一能怀疑的也只有 long cast to int 了！</p>
<p>先看下两种类型取值范围</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>最大值</th>
<th>最小值</th>
</tr>
</thead>
<tbody>
<tr>
<td>int</td>
<td>2^31 - 1 = 2147483647</td>
<td>-2^31 = -2147483648</td>
</tr>
<tr>
<td>long</td>
<td>2^63 - 1 = 9223372036854775807</td>
<td>-2^63 = -9223372036854775808</td>
</tr>
</tbody>
</table>
<p>开始找茬游戏...<br>
于是乎！</p>
<pre><code class="language-java">long x = 2147483648l, long y = 0
(int) (x - y) = (int) 2147483648l = -2147483648
(int) (y - x) = (int) -2147483648l = -2147483648
</code></pre>
<p>神奇的x &lt; y &amp;&amp; y &lt; x 成立了！<br>
合同第一条自反性违反！</p>
<p>再来</p>
<pre><code class="language-java">long x = 2147483648l, long y = 1l, long z = -1l
(int) (x - y) = (int) (2147483647l) = 2147483647
(int) (y - z) = (int) (2l) = 2l
(int) (x - z) = (int) (2147483649l) = -2147483647
</code></pre>
<p>神奇的x &gt; y &amp;&amp; y &gt; z &amp;&amp; x &lt; z 也成立了！</p>
<p>合同第二条传递性违反！</p>
<p>轻轻松松就写了个弥天大bug!</p>
<p>找到问题就好解决了，不用cast就是了。</p>
<pre><code class="language-java">Long.compare(time1, time2);
</code></pre>
<p>Long.compare实现也很简单, 直接比较大小，返回对应int值即可。</p>
<pre><code class="language-java">public static int compare(long x, long y) {
        return (x &lt; y) ? -1 : ((x == y) ? 0 : 1);
    }
</code></pre>
<h2 id="总结">总结</h2>
<p>类型强转，精度丢失会惹祸！！！<br>
类型强转需谨慎，谨慎，再谨慎！！！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android Studio 9-Patch Bug Miss Alpha Channel]]></title>
        <id>https://songhanghang.github.io/post/android-studio-9-patch-bug-miss-alpha-channel</id>
        <link href="https://songhanghang.github.io/post/android-studio-9-patch-bug-miss-alpha-channel">
        </link>
        <updated>2019-08-19T12:20:16.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="问题">问题</h2>
<p>用AS创建9 Patch图时，发现有些图片转换后失去alpha信息，无法编辑描边！</p>
<blockquote>
<p>res -&gt; drawale-xxhdpi -&gt;  target.png -&gt; 右键 Create 9-Patch File</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h2 id="问题">问题</h2>
<p>用AS创建9 Patch图时，发现有些图片转换后失去alpha信息，无法编辑描边！</p>
<blockquote>
<p>res -&gt; drawale-xxhdpi -&gt;  target.png -&gt; 右键 Create 9-Patch File</p>
</blockquote>
<!-- more -->
<h2 id="分析">分析</h2>
<p>对比发现，</p>
<ol>
<li>转换后异常的.9图片为8-bit color 或者 24-bit color, 正常的.9图片均为32-bit color。</li>
<li>如果原图为8-bit color 或者24-bit color , 转换后异常。但是原图为32-bit color 转换后也有可能异常。</li>
</ol>
<p>Google并未有很多反馈，仅有一篇类似问题<a href="https://stackoverflow.com/questions/25171838/9-patch-editor-android-studio-suddenly-black">https://stackoverflow.com/questions/25171838/9-patch-editor-android-studio-suddenly-black</a></p>
<h3 id="png-8-24-32区别介绍">PNG-8、24、32区别介绍</h3>
<p><a href="https://www.jianshu.com/p/31207790bad2">https://www.jianshu.com/p/31207790bad2</a></p>
<h2 id="尝试解决">尝试解决</h2>
<ol>
<li>Sketch重新切图后，转换.9正常（未发现图片有什么不同）</li>
<li>Sketch重新切图后，再压缩后，转换.9正常</li>
<li>使用在线工具<a href="https://romannurik.github.io/AndroidAssetStudio/nine-patches.html#&amp;sourceDensity=320&amp;name=example">Simple nine-patch generator</a>转换8-bit color ,24-bit color ,32-bit color原图都能得到正常的.9图。</li>
</ol>
<h2 id="总结">总结</h2>
<p>Android Studio 9-Patch 直接转换可能丢失位图信息，无法获取32-bit color .9文件。<br>
推荐直接用<a href="https://romannurik.github.io/AndroidAssetStudio/nine-patches.html#&amp;sourceDensity=320&amp;name=example">Simple nine-patch generator</a>转换异常图片。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flutter初识]]></title>
        <id>https://songhanghang.github.io/post/hello-gridea</id>
        <link href="https://songhanghang.github.io/post/hello-gridea">
        </link>
        <updated>2019-07-29T12:09:30.000Z</updated>
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" />
> 参考： 
> [Flutter中文网: https://flutterchina.club](https://flutterchina.club/)
> [Flutter实战: https://book.flutterchina.club](https://book.flutterchina.club/)
> [Demo: https://github.com/songhanghang/flutter_news_demo](https://github.com/songhanghang/flutter_news_demo)
<h2 id="hybrid简介">Hybrid简介</h2>
<h3 id="h5-原生">H5 + 原生</h3>
<p>WebView渲染界面，性能体验相对Native较差。</p>
<h3 id="js开发-原生">JS开发 + 原生</h3>
<p>代表框架React Native, Weex, 快应用, 原理都是JS去映射 Android | IOS 原生控件，原生渲染速度快于H5，受限于JS解释执行，及调用桥开销，速度无法追赶Native。</p>
<h3 id="自研gui-原生">自研GUI + 原生</h3>
<p>代表框架QT, Flutter, 渲染引擎直接对接不同平台系统API, 对外提供统一接口，性能和原生接近，但是动态性不足，需要编译发包。</p>
<blockquote>
<p>PS：QT在桌面端应用比较广泛，但是移动端因引擎大, C++开发效率低，坑多，推出即夭折。</p>
</blockquote>
<h2 id="flutter登场">Flutter登场</h2>
<p>Flutter是Google发布的一个用于创建跨平台、高性能移动应用的框架。Flutter和QT mobile一样，都没有使用原生控件，相反都实现了一个自绘引擎，使用自身的布局、绘制系统。<br>
以下是官网介绍：</p>
<ol>
<li>
<p>快速开发<br>
毫秒级的热重载，修改后，您的应用界面会立即更新。使用丰富的、完全可定制的widget在几分钟内构建原生界面.</p>
</li>
<li>
<p>富有表现力和灵活的UI<br>
快速发布聚焦于原生体验的功能。分层的架构允许您完全自定义，从而实现难以置信的快速渲染和富有表现力、灵活的设计。</p>
</li>
<li>
<p>原生性能<br>
Flutter包含了许多核心的widget，如滚动、导航、图标和字体等，这些都可以在iOS和Android上达到原生应用一样的性能。</p>
</li>
<li>
<p>访问本地功能和SDK<br>
通过平台相关的API、第三方SDK和原生代码让您的应用变得强大易用。 Flutter允许您复用现有的Java、Swift或ObjC代码，访问iOS和Android上的原生系统功能和系统SDK。</p>
</li>
</ol>
<h2 id="flutter思想">Flutter思想</h2>
<h3 id="组合-集成">组合 &gt; 集成</h3>
<p>在Flutter中一切UI相关操作都是Widget，布局，容器，手势，滑动，功能都是Widget, 通过自由组合这些Widget来搭建功能界面。</p>
<h3 id="响应式编程">响应式编程</h3>
<p>响应式编程一句话总结就是<code>数据状态改变则UI随之自动改变</code>，React Native和DataBinding都是该思想产物， 在Flutter中表现的更加淋漓尽致。数据改变时通过setState() {}, 通知Flutter Framework执行Rebuild Widget -&gt; Update Element -&gt; Render UI。</p>
<h2 id="flutter核心原理">Flutter核心原理</h2>
<h3 id="框架分层">框架分层</h3>
<p>Flutter框架是一个分层的结构，每个层都建立在前一层之上。使用Skia渲染引擎，因Android自带Skia, 所以打包Android不包含Skia, 这也是IOS体积较大的重要原因。<br>
<img src="https://wx4.sinaimg.cn/mw690/006292TQly1g48yigwv61j30yu0iyq7m.jpg" alt=""></p>
<h3 id="渲染流程">渲染流程</h3>
<p><img src="https://upload-images.jianshu.io/upload_images/5639324-4424415ff5f8681f.jpg?imageMogr2/auto-orient/" alt=""></p>
<h3 id="三棵神树">三棵神树</h3>
<p><img src="https://upload-images.jianshu.io/upload_images/5639324-611c58af9c948150.jpg" alt=""><br>
所有故事，从这个三棵树开始...<br>
这三颗🌲分别是 Widget Tree, Element Tree, RenderObject Tree.</p>
<h4 id="第一颗widget">第一颗Widget🌲</h4>
<pre><code class="language-dart">/// Describes the configuration for an [Element].
abstract class Widget extends DiagnosticableTree {
  /// Initializes [key] for subclasses.
  const Widget({ this.key });
  final Key key;
  
  @protected
  Element createElement();

  /// A short, textual description of this widget.
  @override
  String toStringShort() {
    return key == null ? '$runtimeType' : '$runtimeType-$key';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.defaultDiagnosticsTreeStyle = DiagnosticsTreeStyle.dense;
  }

  /// Whether the `newWidget` can be used to update an [Element] that currently
  static bool canUpdate(Widget oldWidget, Widget newWidget) {
    return oldWidget.runtimeType == newWidget.runtimeType
        &amp;&amp; oldWidget.key == newWidget.key;
  }
}
</code></pre>
<p>Widget源码注释 <code>Describes the configuration for an [Element].</code><br>
Widget作用就是为Element描述需要的配置， 负责创建Element -&gt; <code>createElement()</code>, 以及决定Element是否需要更新 -&gt; <code>canUpdate(Widget oldWidget, Widget newWidget)</code>.<br>
Flutter Framework通过diff算法比对Widget树变化，然后决定Element的State改变。Rebuild后的Widget树，如果对比未发生改变， 则Element不会触发重绘，这就意味着Widget树的重建并不会直接导致Element树重建。</p>
<h4 id="第二颗element">第二颗Element🌲</h4>
<pre><code class="language-dart">/// An instantiation of a [Widget] at a particular location in the tree.
abstract class Element extends DiagnosticableTree implements BuildContext {
...
  /// The configuration for this element.
  @override
  Widget get widget =&gt; _widget;
  Widget _widget;
  
  /// The render object at (or below) this location in the tree.
  RenderObject get renderObject {
    ...
  }
...
}
</code></pre>
<p>Element源码注释： <code>An instantiation of a [Widget] at a particular location in the tree.</code><br>
Element表示Widget配置树特定位置的一个实例。持有Widget和RenderObject,负责组织管理Widget配置和RenderObject渲染。<br>
可以理解为Android和IOS的View树，但是不同的是Element状态一般由Flutter Framework管理， 开发者只需负责更改Widget即可。</p>
<h4 id="第三颗renderobject">第三颗RenderObject🌲</h4>
<pre><code class="language-dart">/// An object in the render tree.
abstract class RenderObject extends AbstractNode with DiagnosticableTreeMixin implements HitTestTarget {
  ...
  @protected
  void performResize();

  @protected
  void performLayout();

  void paint(PaintingContext context, Offset offset);
  ...
</code></pre>
<p>RenderObject源码注释：  <code>An object in the render tree.</code><br>
RenderObject表示为渲染树的一个对象<br>
顾名思义，RenderObject负责真正的渲染工作，需要自己定义绘制的话就要从此处切入, 测量大小 <code>performResize</code>，定位位置 <code>performLayout</code>， 绘制 <code>paint</code>都由RenderObject完成。</p>
<h4 id="总结">总结</h4>
<p>Widget为配置树， Element为UI控制树，RenderObject为绘制树。开发者组合Widget配置，Framework通过比对Widget配置来创新或更新Element，最后调度RenderObject渲染树进行上屏绘制。</p>
<h2 id="widget-种类">Widget 种类</h2>
<p>Widget本身通常由许多更小的、单一用途widget组成，这些widget结合起来产生强大的效果。例如，Container是一个常用的Widget， 由多个Widget组成，这些widget负责布局、绘制、定位和调整大小。具体来说，Container由 LimitedBox、 ConstrainedBox、 Align、 Padding、 DecoratedBox、 和Transform组成。 您可以用各种方式组合这些以及其他简单的Widget，而不是继承容器。</p>
<p>类层次结构很浅且很宽，可以最大限度地增加可能的组合数量。<br>
<img src="https://wx1.sinaimg.cn/mw690/006292TQly1g48yigwyf5j315u0nwq58.jpg" alt=""></p>
<h3 id="stateless-widget">Stateless Widget</h3>
<p>无状态Widget, 使用于不需要维护状态的场景，即创建后不可修改配置数据。</p>
<pre><code class="language-dart">abstract class StatelessWidget extends Widget {
  const StatelessWidget({ Key key }) : super(key: key);

  @override
  StatelessElement createElement() =&gt; StatelessElement(this);
  
  @protected
  Widget build(BuildContext context);
}
</code></pre>
<p>对应StatelessElement， 其中BuildContext即为对应的Element实例。</p>
<h3 id="statefulwidget">StatefulWidget</h3>
<p><img src="https://wx1.sinaimg.cn/mw690/006292TQly1g48yigw7ebj30zk0i4abe.jpg" alt="-w640"></p>
<p>有状态widget, 通过setState(), 可以触发rebuild Widget, 从而刷新界面。<br>
适用于数据改变需要刷新界面的场景。</p>
<pre><code class="language-dart">abstract class StatefulWidget extends Widget {
  const StatefulWidget({ Key key }) : super(key: key);

  @override
  StatefulElement createElement() =&gt; new StatefulElement(this);

  @protected
  State createState();
}

class StatefulElement extends ComponentElement {
  StatefulElement(StatefulWidget widget)
      : _state = widget.createState(),
        super(widget) {
       }());
    assert(_state._element == null);
    _state._element = this;
    assert(_state._widget == null);
    _state._widget = widget;
    assert(_state._debugLifecycleState == _StateLifecycle.created);
  }
}

</code></pre>
<p>对应StatefulElement， State在StatefulElement初始化时创建， State和StatefulElement相互持有，意味着State不会随着StatefulWidget重建, State持有StatefulWidget.</p>
<pre><code class="language-dart">class _PageWidgetState extends State&lt;_PageWidget&gt; {
  final GlobalKey&lt;RefreshIndicatorState&gt; _refreshIndicatorKey =
      GlobalKey&lt;RefreshIndicatorState&gt;();

  @override
  void initState() {
    super.initState();
    _refreshData();
  }

  Future _refreshData() async {
    Response response = await widget.page._request();
    setState(() {});
    return response;
  }

  @override
  Widget build(BuildContext context) {
    return RefreshIndicator(
      key: _refreshIndicatorKey,
      onRefresh: _refreshData,
    
      ...
    );
  }
</code></pre>
<p>State通过setState(), 触发Rebuild.</p>
<h2 id="依赖管理">依赖管理</h2>
<p>使用pubspec.yaml管理依赖，类似于Android Gradle, IOS Cocoapods.<br>
<strong>eg:</strong></p>
<pre><code>name: flutter_in_action
description: First Flutter application.

version: 1.0.0+1

dependencies:
  flutter:
    sdk: flutter
  cupertino_icons: ^0.1.2

dev_dependencies:
  flutter_test:
    sdk: flutter

flutter:
  uses-material-design: true
</code></pre>
<h2 id="资源管理">资源管理</h2>
<p>Flutter应用程序可以包含代码和 assets（有时称为资源）。assets是会打包到程序安装包中的，可在运行时访问。常见类型的assets包括静态数据（例如JSON文件）、配置文件、图标和图片（JPEG，WebP，GIF，动画WebP / GIF，PNG，BMP和WBMP）等。<br>
Flutter也使用pubspec.yaml文件来管理应用程序所需的资源</p>
<pre><code>  flutter:
  assets:
    - assets/my_icon.png
    - assets/background.png
</code></pre>
<h2 id="开发工具">开发工具</h2>
<p>工欲善其事必先利其器<br>
环境配置略过...</p>
<h3 id="ide插件">IDE插件</h3>
<p>Flutter提供Android Studio和VS Code插件，这里只看Android Studio. 需下载flutter和dart插件, 安装后如图<br>
<img src="https://wx2.sinaimg.cn/mw1024/006292TQly1g48yih40xgj30u00ym1kx.jpg" alt="-w1148"></p>
<h3 id="code打开">Code打开</h3>
<p>还有一些工具需要通过代码打开。</p>
<pre><code class="language-dart">void main() {
    debugPaintSizeEnabled = true; // 显示文字基准线
    debugPaintPointersEnabled = true; // 突出点击对象
    debugPaintLayerBordersEnabled = true; // 显示层级边界
    debugRepaintRainbowEnabled = true; // 显示重绘
    runApp(MyApp());
}
</code></pre>
<h3 id="一些有意思的工具">一些有意思的工具</h3>
<h4 id="select-widget-mode">Select Widget Mode</h4>
<p>滑动时显示触摸区域对应的Widget类型。</p>
<p><img src="https://wx2.sinaimg.cn/mw690/006292TQly1g491cv5nf9g30a80fl7wl.gif" alt=""></p>
<h4 id="refresh-widget-info">Refresh Widget Info</h4>
<p>刷新 rebuild widget。</p>
<h4 id="show-performance-overlay">Show Performance Overlay</h4>
<p>显示每帧GPU绘制时间，和UI绘制时间，分别显示单帧最大绘制时间和平均绘制时间，debug模式JIT边解释边执行导致UI不能跑慢60帧每秒。</p>
<p><img src="https://wx2.sinaimg.cn/mw690/006292TQly1g491nqk44og30ah0ilqv8.gif" alt=""></p>
<h4 id="toggle-platform">Toggle Platform</h4>
<p>切换Android和IOS平台, 注意不只是TitleBar显示效果不同，转场动画也不相同。</p>
<p><img src="https://wx1.sinaimg.cn/mw690/006292TQly1g4920glkqhg309r0hbe84.gif" alt=""></p>
<p><img src="https://wx3.sinaimg.cn/mw690/006292TQly1g4920i5z51g30a40hykjo.gif" alt=""></p>
<h4 id="show-debug-paint">Show Debug Paint</h4>
<p>显示View边框</p>
<p><img src="https://wx1.sinaimg.cn/mw690/006292TQly1g492agwkb1j30am0ixqbm.jpg" alt=""></p>
<h4 id="show-paint-baselines">Show Paint Baselines</h4>
<p>显示Text基准线</p>
<p><img src="https://wx1.sinaimg.cn/mw690/006292TQly1g492cebm1pj30am0ixagj.jpg" alt=""></p>
<h4 id="debugpaintpointersenabled">debugPaintPointersEnabled</h4>
<p>显示突出对象</p>
<p><img src="https://wx3.sinaimg.cn/mw690/006292TQly1g492kv7r98j30am0ix43o.jpg" alt=""></p>
<h4 id="debugpaintlayerbordersenabled">debugPaintLayerBordersEnabled</h4>
<p>显示层级边界</p>
<p><img src="https://wx3.sinaimg.cn/mw690/006292TQly1g492n56azoj30am0ixn3a.jpg" alt=""></p>
<h4 id="debugrepaintrainbowenabled">debugRepaintRainbowEnabled</h4>
<p>显示重绘</p>
<p><img src="https://wx2.sinaimg.cn/mw690/006292TQly1g492qil7dwg30a40hy7wj.gif" alt=""></p>
<h2 id="开源库支持">开源库支持</h2>
<p><a href="https://pub.dev/flutter">https://pub.dev/flutter</a><br>
<img src="https://wx1.sinaimg.cn/mw690/006292TQly1g4c115fuhaj30u01144ky.jpg" alt=""><br>
Flutter已有很多高质量的开源库，涵盖常用的网络请求，数据库，图片处理，图片选择器，地图，支付，WebView ，路由，shared_preferences等等。各大厂也在积极的推进Flutter, 相信未来Flutter开发会更简单和快速。</p>
<h2 id="总结-2">总结</h2>
<pre><code>Makes it easy and fast to build beautiful mobile apps
for iOS and Android.
</code></pre>
<p>Fultter开发很像是积木游戏，功能丰富的组件，能让你简单快速的搭建漂亮且高性能的App。现在各大厂都有Flutter尝试，闲鱼已经在生产环境玩很久，华为的鸿蒙系统更是直接集成了Flutter环境，燎原之势已起。</p>
<p>后续Flutter如果能顺利推进Web, MacOS, Linux, Window支持，相信一门语言走天下的那一天就要来了...</p>
<h2 id="demo-新闻客户端">DEMO 新闻客户端</h2>
<p><a href="https://github.com/songhanghang/flutter_news_demo"><strong>https://github.com/songhanghang/flutter_news_demo</strong></a></p>
<p><img src="https://wx2.sinaimg.cn/mw690/006292TQly1g3v1ygaisdg30dc0np1l0.gif" alt="gif"></p>
<p>源码：</p>
<pre><code class="language-dart">import 'dart:async';
import 'dart:convert';

import 'package:flutter/material.dart';
import 'package:flutter/rendering.dart';
import 'package:dio/dio.dart';
import 'package:flutter_webview_plugin/flutter_webview_plugin.dart';

Dio dio = Dio();

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: ScrollableTabsDemo(),
    );
  }
}

class _Page {
  _Page({this.text, this.key})
      : this.url = &quot;https://3g.163.com/touch/reconstruct/article/list/$key/0-20.html&quot;;
  final String text;
  final String key;
  final String url;
  final List&lt;_News&gt; list = List();

  Future _request() async {
    Response response = await dio.get(url);
    String value = response.toString();
    value = value.substring(9, value.length - 1);
    Map&lt;String, dynamic&gt; map = json.decode(value);
    List data = map[key];
    list.clear();
    data.forEach((value) {
      list.add(_News.fromJson(value));
    });
    return response;
  }
}

class _News {
  final String title;
  final String url;
  final String skpUrl;
  final String image;
  final String digest;
  final String time;

  _News.fromJson(Map&lt;String, dynamic&gt; json)
      : title = json[&quot;title&quot;],
        url = json[&quot;url&quot;],
        skpUrl = json[&quot;skipURL&quot;],
        image = json[&quot;imgsrc&quot;],
        digest = json[&quot;digest&quot;],
        time = json[&quot;ptime&quot;];
}

List&lt;_Page&gt; _allPages = &lt;_Page&gt;[
  _Page(text: '新闻', key: &quot;BBM54PGAwangning&quot;),
  _Page(text: '娱乐', key: &quot;BA10TA81wangning&quot;),
  _Page(text: '体育', key: &quot;BA8E6OEOwangning&quot;),
  _Page(text: '财经', key: &quot;BA8EE5GMwangning&quot;),
  _Page(text: '军事', key: &quot;BAI67OGGwangning&quot;),
  _Page(text: '科技', key: &quot;BA8D4A3Rwangning&quot;),
  _Page(text: '手机', key: &quot;BAI6I0O5wangning&quot;),
  _Page(text: '数码', key: &quot;BAI6JOD9wangning&quot;),
  _Page(text: '时尚', key: &quot;BA8F6ICNwangning&quot;),
  _Page(text: '游戏', key: &quot;BAI6RHDKwangning&quot;),
  _Page(text: '教育', key: &quot;BA8FF5PRwangning&quot;),
  _Page(text: '健康', key: &quot;BDC4QSV3wangning&quot;),
  _Page(text: '旅游', key: &quot;BEO4GINLwangning&quot;),
];

class ScrollableTabsDemo extends StatefulWidget {
  @override
  _ScrollableTabsState createState() =&gt; _ScrollableTabsState();
}

class _ScrollableTabsState extends State&lt;ScrollableTabsDemo&gt;
    with SingleTickerProviderStateMixin {
  TabController _controller;

  @override
  void initState() {
    super.initState();
    _controller = TabController(vsync: this, length: _allPages.length);
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  Decoration _getIndicator() {
    return ShapeDecoration(
      shape: const RoundedRectangleBorder(
            borderRadius: BorderRadius.all(Radius.circular(8.0)),
            side: BorderSide(color: Colors.white70, width: 1.5),
          ) +
          const RoundedRectangleBorder(
            borderRadius: BorderRadius.all(Radius.circular(4.0)),
            side: BorderSide(color: Colors.transparent, width: 8.0),
          ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: NestedScrollView(
        headerSliverBuilder: (BuildContext context, bool innerBoxIsScrolled) {
          return &lt;Widget&gt;[
            SliverOverlapAbsorber(
              handle: NestedScrollView.sliverOverlapAbsorberHandleFor(context),
              child: SliverAppBar(
                title: const Text('News'),
                pinned: false,
                backgroundColor: Colors.red,
                forceElevated: innerBoxIsScrolled,
                bottom: TabBar(
                  controller: _controller,
                  isScrollable: true,
                  labelColor: Colors.white,
                  indicator: _getIndicator(),
                  tabs: _allPages.map&lt;Tab&gt;((_Page page) {
                    return Tab(text: page.text);
                  }).toList(),
                ),
              ),
            ),
          ];
        },
        body: TabBarView(
          controller: _controller,
          children: _allPages.map&lt;Widget&gt;((_Page page) {
            return SafeArea(
              top: false,
              bottom: true,
              child: _PageWidget(page),
            );
          }).toList(),
        ),
      ),
    );
  }
}

class _PageWidget extends StatefulWidget {
  const _PageWidget(this.page, {Key key}) : super(key: key);
  final _Page page;

  @override
  State&lt;StatefulWidget&gt; createState() {
    return _PageWidgetState();
  }
}

class _PageWidgetState extends State&lt;_PageWidget&gt; {
  final GlobalKey&lt;RefreshIndicatorState&gt; _refreshIndicatorKey =
      GlobalKey&lt;RefreshIndicatorState&gt;();

  @override
  void initState() {
    super.initState();
    _refreshData();
  }

  Future _refreshData() async {
    Response response = await widget.page._request();
    setState(() {});
    return response;
  }

  @override
  Widget build(BuildContext context) {
    return RefreshIndicator(
      key: _refreshIndicatorKey,
      onRefresh: _refreshData,
      child: Scrollbar(
        child: ListView.builder(
          padding: kMaterialListPadding,
          itemCount: widget.page.list.length,
          itemBuilder: (BuildContext context, int index) {
            return GestureDetector(
              onTap: () {
                Navigator.push(context, MaterialPageRoute(builder: (context) {
                  String url = widget.page.list[index].url;
                  if (!url.startsWith(&quot;http&quot;)) {
                    url = widget.page.list[index].skpUrl;
                  }
                  return WebviewScaffold(
                      appBar: AppBar(title: Text(&quot;详情&quot;), backgroundColor: Colors.red),
                      url: url);
                }));
              },
              child: Padding(
                  padding: EdgeInsets.all(8.0),
                  child: Row(
                    children: &lt;Widget&gt;[
                      DecoratedBox(
                        decoration: BoxDecoration(
                            borderRadius: BorderRadius.circular(3.0),
                            boxShadow: [
                              BoxShadow(
                                  color: Colors.black54,
                                  offset: Offset(2.0, 2.0),
                                  blurRadius: 4.0)
                            ]),
                        child: Image.network(
                          widget.page.list[index].image,
                          width: 140,
                          height: 80,
                          fit: BoxFit.cover,
                        ),
                      ),
                      Expanded(
                          flex: 1,
                          child: Padding(
                              padding: EdgeInsets.only(left: 10),
                              child: Align(
                                  alignment: Alignment.centerLeft,
                                  child: Wrap(
                                    children: &lt;Widget&gt;[
                                      Text(widget.page.list[index].title),
                                      Text(
                                        widget.page.list[index].digest,
                                        style: TextStyle(
                                            color: Colors.black87,
                                            fontSize: 10.0),
                                      ),
                                      Text(
                                        widget.page.list[index].time,
                                        style: TextStyle(
                                            color: Colors.black54,
                                            fontSize: 8.0),
                                      )
                                    ],
                                  ))))
                    ],
                  )),
            );
          },
        ),
      ),
    );
  }
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redcord 连接你我]]></title>
        <id>https://songhanghang.github.io/post/redcord-lian-jie-ni-wo</id>
        <link href="https://songhanghang.github.io/post/redcord-lian-jie-ni-wo">
        </link>
        <updated>2019-06-06T11:59:33.000Z</updated>
        <summary type="html"><![CDATA[<meta name="referrer" content="no-referrer" />
非常抱歉，因近期政策原因，储存服务必须备案，费用不低，所以10月1号起有可能随时停服...
<p>在此祝各位幸福哦！</p>
<p>是否遇到过，有急事找Ta, 但是电话打不通，微信没人接，即使科技再发达，找Ta时你也抓瞎！</p>
]]></summary>
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" />
非常抱歉，因近期政策原因，储存服务必须备案，费用不低，所以10月1号起有可能随时停服...
<p>在此祝各位幸福哦！</p>
<p>是否遇到过，有急事找Ta, 但是电话打不通，微信没人接，即使科技再发达，找Ta时你也抓瞎！</p>
<!-- more -->
<blockquote>
<p>红绳-连接你我<br>
<a href="https://github.com/songhanghang/redcord">https://github.com/songhanghang/redcord</a></p>
</blockquote>
<p>如果你和家人都是iphone用户，可以开启<a href="https://support.apple.com/zh-cn/HT201087">家人位置共享</a>，这样可以随时随地查看Ta在什么位置。</p>
<p>Android现在并没有很好的解决方案，强大如微信也必须手动开启位置共享，当然微信不做是有他的道理...</p>
<p>但是我确实有这样的需求，我的TA只要一出门，那是永远联系不上的, 嗯！确实有必要&quot;偷偷&quot;给她定位！于是乎，手撕了这个程序...</p>
<p>先梳理下有哪些需求：</p>
<ol>
<li>需要定位</li>
<li>需要把定位信息同步给我</li>
<li>需要程序一直活着</li>
</ol>
<p>定位问题高德地图SDK解决，同步问题leancloud解决，怎么才能一直活着，这是个头疼的问题，微信可以被各大手机厂商白名单呵护着, 但是一般App不可能有这个待遇。</p>
<p>业内能人志士为了保活使出各种奇淫技巧，例如：</p>
<ol>
<li>双进程互调</li>
<li>可见前台进程</li>
<li>一个可见像素点Activity</li>
<li>应用联盟(流氓联盟)，通过不同的App发广播互调</li>
<li>利用Android系统漏洞<br>
总之黑白手段都有，但是活的都不光彩，程序还是要漂亮的活着！</li>
</ol>
<p>于是乎想到了Android的动态壁纸，这玩意好，壁纸是脸面，系统要脸，就不能让它死，死了也要主动拉起来!</p>
<p>那么做个好看的动态壁纸，通过壁纸定位和同步信息就可以解决这个问题.</p>
<p>Coding....</p>
<p>emmmmm....</p>
<p><img src="https://wx1.sinaimg.cn/mw690/006292TQly1g25r4ipgbkg30bd0om4qr.gif" alt="图片"></p>
<h3 id="下载">下载</h3>
<p><img src="https://wx4.sinaimg.cn/mw690/006292TQly1g3ac6bxnz9j30440440b9.jpg" alt="图片"></p>
<p><a href="https://www.coolapk.com/apk/com.song.redcord">https://www.coolapk.com/apk/com.song.redcord</a></p>
<h3 id="软件功能介绍">软件功能介绍</h3>
<h4 id="注册与登录">注册与登录</h4>
<p>注册不需要手机号,不需要邮箱（不会上传你的隐私），直接点击注册即可，注册成功后会生成你的ID, 显示在屏幕的左上角，这是你以后登录的唯一凭证（注意保密），注册成功后，需要配对TA的ID, 才能使用，也可以发送自己ID给Ta, 让对方完成配对。配对完成请及时在详情页备份两人Id。<br>
你与Ta的ID唯一绑定，绑定后不可解绑，或者与他人绑定。</p>
<h4 id="主界面">主界面</h4>
<p>App地图界面，左上角显示两人ID, 中间为彼此位置及驾车导航路线，信息框显示Ta的位置信息，提供一些常用功能:</p>
<ol>
<li>见Ta       <code>一键导航见Ta，高德，百度地图</code></li>
<li>设置壁纸</li>
<li>备份       <code>备份两人ID, 以便换手机，或者清空缓存找回</code></li>
<li>打赏       <code>用的leancloud的服务，免费的访问量很少，很期望您的支持</code></li>
<li>关于       <code>指向这篇ReadMe</code></li>
</ol>
<h4 id="动态壁纸">动态壁纸</h4>
<p>这是个魔性的壁纸，屏幕上一根红绳在不停扭动，线的两端连着两个圆，象征着彼此，中间显示着实时位置距离，背景色随着扭动渐变，触摸屏幕动画随手而动，早上，下午，晚上三组颜色自动切换。</p>
<h4 id="其他">其他</h4>
<ol>
<li>耗电   <code>主界面:10s定位一次，退出后不再定位;动态壁纸:可见时30s定位一次，不可见不定位。所以不用担心耗电问题</code></li>
<li>用户隐私 <code>没有上传你任何其他信息，自行查看代码</code></li>
<li>数据服务 <code>用的leancloud提供数据支持，每天只有3万次免费请求，所以急需您的支持</code></li>
<li>Bug <code>小米手机上完成的开发测试，其他机器有问题，欢迎反馈</code></li>
</ol>
<h3 id="联系方式">联系方式</h3>
<p>邮箱: 1131442853@qq.com</p>
<p><a href="https://github.com/songhanghang">github: https://github.com/songhanghang</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MakeFile指南]]></title>
        <id>https://songhanghang.github.io/post/makefile-zhi-nan</id>
        <link href="https://songhanghang.github.io/post/makefile-zhi-nan">
        </link>
        <updated>2018-07-01T12:13:27.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>参考:<br>
GNU make: <a href="https://www.gnu.org/software/make/manual/make.html">https://www.gnu.org/software/make/manual/make.html</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>参考:<br>
GNU make: <a href="https://www.gnu.org/software/make/manual/make.html">https://www.gnu.org/software/make/manual/make.html</a></p>
</blockquote>
<!-- more -->
<blockquote>
<p>Android.mk: <a href="https://developer.android.com/ndk/guides/android_mk.html?hl=zh-cn">https://developer.android.com/ndk/guides/android_mk.html?hl=zh-cn</a></p>
<p>陈皓: <a href="https://seisman.github.io/how-to-write-makefile/">https://seisman.github.io/how-to-write-makefile/</a></p>
<p>建议:<br>
推荐使用Sublime Text进行makefile开发，Sublime Text支持makefile语法高亮，自动编译，编译错误提示，虽支持功能甚少，但聊胜于无，能让你感觉自己是在写代码，而不是在编辑文本😒</p>
</blockquote>
<h2 id="makefile介绍">Makefile介绍</h2>
<h3 id="起源">起源</h3>
<p>斯图亚特·费尔德曼在1977年在贝尔实验室里制作了这个软件。2003年，斯图亚特·费尔德曼因发明了这样一个重要的工具而接受了美国计算机协会（ACM）颁发的软件系统奖。<br>
在make诞生之前，编译工作主要依赖于操作系统里面的类似于“make”、“install”功能的shell脚本。它可以批量执行生成目标的命令，并且可以完成依赖关系的检查。这是向现代编译环境发展的重要一步。</p>
<h3 id="概述">概述</h3>
<blockquote>
<p>维基百科：<br>
Most often, the makefile directs make on how to compile and link a program. Using C/C++ as an example, when a C/C++ source file is changed, it must be recompiled. If a header file has changed, each C/C++ source file that includes the header file must be recompiled to be safe. Each compilation produces an object file corresponding to the source file. Finally, if any source file has been recompiled, all the object files, whether newly made or saved from previous compilations, must be linked together to produce the new executable program. These instructions with their dependencies are specified in a makefile. If none of the files that are prerequisites have been changed since the last time the program was compiled, no actions take place. For large software projects, using Makefiles can substantially reduce build times if only a few source files have changed</p>
</blockquote>
<p>通常，makefile指定如何编译和链接程序。以C/C++为例，当C/C++源文件被改变时，必须重新编译。如果头文件已经改变，那么包含头文件的每个C/C++源文件都必须重新编译以确保安全。每个编译生成一个对应于源文件的目标文件。最后，如果所有源文件已经被重新编译，所有的目标文件，无论是新建的还是从以前的编译中保存的，都必须链接在一起，以产生新的可执行程序。这些指令及其依赖关系在makefile中指定。如果自上次编译程序以来没有任何先决条件的文件发生更改，则不会执行任何操作。对于大型软件项目，如果只有少数源文件发生更改，则使用Makefile可以显着缩短生成时间。</p>
<h2 id=""></h2>
<h3 id="核心规则">核心规则</h3>
<pre><code class="language-makefile">target ... : prerequisites ...
    command
    ...
    ...
</code></pre>
<p><strong>target</strong><br>
可以是一个object file*（目标文件）<em>，也可以是一个执行文件，还可以是一个标签</em>（label）*<br>
<strong>prerequisites</strong><br>
生成该target所依赖的文件或target<br>
<strong>command</strong><br>
该target要执行的命令*（任意的shell命令）*</p>
<p>makefile最核心内容：  <em><strong>prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。</strong></em></p>
<h3 id="如何工作">如何工作</h3>
<pre><code class="language-Shell"># 自动编译当前目录下名字叫“Makefile”或“makefile”的文件（不带后缀）
make
# 或者指定自定义名字makefile文件
make -f custom.mk
</code></pre>
<ol>
<li>make会查找文件中第一个target文件，如果能够找到并且target所依赖的prerequisites文件的修改时间不比target文件新，则将其作为最终的目标文件。</li>
<li>否则，执行后面定义的command生成新的target文件。</li>
<li>如果prerequisites文件也不存在，那么make会在当前makefile中找到prerequisites作为target的依赖，如果找到再根据其规则生成该prerequisites文件，以此递归，直至找到递归出口收拢结束。</li>
</ol>
<h3 id="包含内容">包含内容</h3>
<p>Makefile里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。</p>
<ol>
<li>显式规则。显式规则说明了如何生成一个或多个目标文件。这是由Makefile的书写者明显指出要生成的 文件、文件的依赖文件和生成的命令。</li>
<li>隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较简略地书写 Makefile，这是由make所支持的。</li>
<li>变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点像你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。</li>
<li>文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一 样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。</li>
<li>注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用 # 字符，这个就 像C/C++中的//一样。如果你要在你的Makefile中使用 # 字符，可以用反斜杠进行 转义，如： # 。</li>
</ol>
<p>最后，还值得一提的是，在Makefile中的命令，必须要以 Tab 键开始。</p>
<h3 id="引用其它makefile">引用其它makefile</h3>
<pre><code class="language-makefile"># filename 可包含路径和通配符
include &lt;filname&gt;
</code></pre>
<p>include 前可有空格，but绝不可以 Tab 键开始，make命令开始时，会找寻 include 所指出的其它Makefile，并把其内容在当前的位置展开。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找。</p>
<ol>
<li>如果make执行时，有 -I 或 --include-dir 参数，那么make就会在这个参数所指定的目 录下去寻找。</li>
<li>如果目录 <prefix>/include （一般是： /usr/local/bin 或 /usr/include ）存在的话，make也会去找。</li>
</ol>
<p>如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以 在include前加一个减号“-”。如：</p>
<pre><code># - 错误跳过
-include &lt;filename&gt;
</code></pre>
<h3 id="执行顺序">执行顺序</h3>
<ol>
<li>
<p>读入执行的Makefile。</p>
</li>
<li>
<p>读入被include的其它Makefile。</p>
</li>
<li>
<p>初始化文件中的变量。</p>
<pre><code> Note: target目标变量此时不会展开求值！！！
 Note: 读取Makefile时就计算条件表达式的值，并根据条件表达式的值来选择语句。 
   PS:（个人理解： 1, 2 是包含 3 的，读入的同时初始化变量）
</code></pre>
</li>
<li>
<p>推导隐晦规则，并分析所有规则。</p>
</li>
<li>
<p>为所有的目标文件创建依赖关系链。</p>
</li>
<li>
<p>根据依赖关系，决定哪些目标要重新生成。</p>
<pre><code> Note: 执行命令前，会展开所有$(varname)变量进行求值，如果找不到该变量，则返回对应的string，``（eg：$(songhanghang) 找不到则返回songhanghang），
</code></pre>
</li>
<li>
<p>执行生成命令。</p>
<pre><code> Note: target变量已经展开求值！！！
       在command中引用shell变量需使用$$varname， (eg: $$(ls | grep &quot;haha&quot;) 执行command时会对其求值)
</code></pre>
</li>
</ol>
<h2 id="makefile规则">Makefile规则</h2>
<h3 id="语法">语法</h3>
<ul>
<li>规则包含两个部分，一个是依赖关系，一个是生成目标的方法</li>
<li>command 前面必须以tab开头，如果command过长可以使用反斜杠“\”进行换行</li>
<li>command 会以UNIX的标准Shell进行执行，即<code>/bin/sh</code>来执行命令</li>
</ul>
<pre><code class="language-makefile"># 依赖关系
targets : prerequisites
# 目标生成方法
    command
    ...
</code></pre>
<p>或者</p>
<pre><code class="language-makefile"># 依赖关系                目标生成方法
targets : prerequisites; command
    command
    ...
</code></pre>
<h3 id="通配符">通配符</h3>
<p>通配符和UNIX的Shell一致</p>
<pre><code>*.mtz     所有后缀mtz的文件  
~/miui     根目录下的miui文件，即$HOME/miui
...
</code></pre>
<h3 id="文件搜索">文件搜索</h3>
<p>make在查找文件依赖时可以指定文件路径，（eg：/Users/songhang/miuidev），也可以通过 <em><strong>特殊变量 <code>VPATH</code></strong></em> 来告诉make路径，让其自动查找。当make在当前目录找不到时，则会到指定的目录进行查找。</p>
<pre><code># 由 ：“冒号”分割，按照先后顺序查找
VPATH = theme ： ../miui
</code></pre>
<p>另可以通过 ***关键字 <code>vpath</code>***更灵活的控制搜索目录，注意是关键字不是变量。</p>
<pre><code># Note: vapth使用方法中的&lt;pattern&gt;需要包含 % 字符，% 的意思是匹配零或若干字符

# 为符合模式&lt;pattern&gt;的文件指定搜索目录&lt;directories&gt;
vpath &lt;pattern&gt; &lt;directories&gt;

# eg：从平级目录miui中查找所有后缀mtz文件
vpath %.mtz ../miui

# 清除符合模式&lt;pattern&gt;的文件的搜索目录
vpath &lt;pattern&gt;

# eg：清除之前定义的../miui搜索目录
vpath %.mtz

# 清除所有已被设置好了的文件搜索目录
vpath
</code></pre>
<h3 id="伪目标">伪目标</h3>
<pre><code>.PHONY : clean
clean:
    rm -rf miui/out
</code></pre>
<p><code>.PHONY</code> 即是这个伪目标，因为并不生成 <code>clean</code> 文件，所以伪目标并不是一个文件，只是一个标签，make无法生成它的依赖关系和决定他是否执行，只有通过显式的指定这个&quot;目标&quot; <code>make clean</code> 才能使其执行，为避免与文件重名，一般使用 <code>.PHONY</code> 来显式指明这个伪目标。<br>
伪目标一般没有依赖的文件。但是，也可以为伪目标指定所依赖的文件。</p>
<h3 id="多目标">多目标</h3>
<pre><code>target1 target2 : /miui/icons
zip -rq /miui/icons $@
</code></pre>
<p>等价于</p>
<pre><code># $@ == target1
target1 : /miui/icons
zip -rq /miui/icons $@

# $@ == target2
target2 : /miui/icons
zip -rq /miui/icons $@
</code></pre>
<h3 id="静态模式">静态模式</h3>
<pre><code># targets定义了一系列的目标文件，可以有通配符。是目标的一个集合
# target-parrtern是指明了targets的模式，也就是的目标集模式
# prereq-parrterns是目标的依赖模式，它对target-parrtern形成的模式再进行一次依赖目标的定义
&lt;targets ...&gt; : &lt;target-pattern&gt; : &lt;prereq-patterns ...&gt;
    &lt;commands&gt;
    ...
   
# 匹配 targets 中以.o为后缀的 target，用对应的miui1.c miui2.c 编译生成
targets = miui1.o miui2.o
$(targets) : %.o : %.c
...
</code></pre>
<p>等价于</p>
<pre><code>miui1.o : miui1.c
...
miui2.o : miui2.c
...
</code></pre>
<h3 id="自动生成依赖">自动生成依赖</h3>
<pre><code># 把变量中所有.c换成.mk
sources = miui1.c miui2.c

include $(sources:.c=.mk)
</code></pre>
<p>等价于</p>
<pre><code>include miui1.mk
include miui2.mk
</code></pre>
<h2 id="makefile命令">Makefile命令</h2>
<h3 id="显示命令">显示命令</h3>
<p>默认执行 command 时会打印该 command，如果不想打印该 command 可以在前加 <code>@</code></p>
<pre><code># command
echo 正在编译miui...
</code></pre>
<p>输出结果</p>
<pre><code>echo 正在编译miui...
正在编译miui...
</code></pre>
<pre><code># command
@echo 正在编译miui...
</code></pre>
<p>输出结果</p>
<pre><code>正在编译miui...
</code></pre>
<p>只显示命令，但不执行命令，方便用于调试makefile</p>
<pre><code>make -n
make --just-print
</code></pre>
<p>安静执行，不显示命令</p>
<pre><code>make -s
make --silent
make --quiet
</code></pre>
<h3 id="命令执行">命令执行</h3>
<ul>
<li>每行命令处于独立的进程，作用域限于当前行，离开当前行失效。</li>
<li>可以用 <code>;</code> 分隔写在一行表示一行。</li>
<li>可以用 <code>;\</code> 分隔写在两行表示一行。</li>
</ul>
<pre><code># pwd 输出根目录 eg: /songhang/
cd miui/icons
pwd

# pwd 输出 miui/icons
cd miui/icons; pwd

# pwd 输出 miui/icons
cd miui/icons;\
pwd
</code></pre>
<h3 id="命令出错">命令出错</h3>
<pre><code># 执行命令忽略错误
make -i
make --ignore-errors

# 如果某规则中的命令出错了，那么就终止该规则的执行，但继续执行其它规则
make -k
make --keep-going
</code></pre>
<p>而如果一个规则是以 <code>.IGNORE</code> 作为目标的，那么这个规则中的所有命令将会忽略错误。</p>
<h3 id="嵌套执行make">嵌套执行make</h3>
<p>嵌套命令执行make，可以不通过<code>include</code>执行其他makefile</p>
<pre><code>cgoogle:
    cd googledir &amp;&amp; $(MAKE)
</code></pre>
<p>等价于</p>
<pre><code>cgoogle:
    $(MAKE) -C googledir
</code></pre>
<h3 id="定义命令包">定义命令包</h3>
<p>如果makefile中出现相同命令序列，那么可以为其定义一个变量，类似于定义方法。</p>
<pre><code># $@ == mi6 $^ == Snapdragon835
define makemi
    zip -rq $@ $^
endef

mi6 : Snapdragon835
    $(makemi)
</code></pre>
<h2 id="makefile变量">Makefile变量</h2>
<h3 id="变量基础">变量基础</h3>
<p>变量声明时需要赋予初值，使用时需要前面加 <code>$</code> ，然后用 <code>()</code> 把变量包起来。</p>
<p>Note:</p>
<pre><code># Note: 声明变量时添加一个或者多个空格以后增加#注释，会对该变量增加一个空格
dir := /miui/icons    # directory to miui icons
all :
# 此处会error，因/miui/icons /res找不到
    cd $(dir)/res/
</code></pre>
<h3 id="变量中引用变量">变量中引用变量</h3>
<pre><code># 用 = 等号赋值，前面的变量可以引用后面的变量
a = $(b)
b = $(c)
c = are you ok ?
all:
    @echo $(a)
</code></pre>
<p>输出结果</p>
<pre><code>are you ok ?
</code></pre>
<pre><code># 用 := 等号赋值，前面的变量不可以引用后面的变量
a := $(b)
b := $(c)
c := are you ok ?
all:
    @echo $(a)
</code></pre>
<p>输出结果</p>
<pre><code># 无输出
</code></pre>
<pre><code># 如果buyPhone没有被定义过，则赋值mix2，否则什么也不做
buyPhone ?= mix2
</code></pre>
<p>等价于</p>
<pre><code class="language-makefile">ifeq ($(origin buyPhone), undefined)
    buyPhone = mix2
endif
</code></pre>
<h3 id="变量高级用法">变量高级用法</h3>
<pre><code># $(var:a=b) 把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串
# themeMtz := 默认.mtz 无界.mtz
themeZip := 默认.zip 无界.zip
themeMtz := $(themeZip: .zip=.mtz)
</code></pre>
<h3 id="追加变量">追加变量</h3>
<pre><code># += 追加变量
# iconsPath = /miui/v6/common/theme/icons /miui/v6/common/devices/theme/icons
iconsPath := /miui/v6/common/theme/icons
iconsPath += /miui/v6/common/devices/theme/icons
</code></pre>
<h3 id="override-指示符">override 指示符</h3>
<pre><code># 如果有变量是通过make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用“override”指示符
override &lt;variable&gt;; = &lt;value&gt;;
override &lt;variable&gt;; := &lt;value&gt;;
# 追加变量
override &lt;variable&gt;; += &lt;more text&gt;;
# 对于多行的变量定义，我们用define指示符，在define指示符前，也同样可以使用override指示符
override define foo
bar
endef
</code></pre>
<h3 id="多行变量">多行变量</h3>
<p>还有一种设置变量值的方法是使用define关键字。使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令（前面***Makefile命令/定义命令包***也是使用该关键字）。</p>
<p><code>define</code> 指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以 <code>endef</code> 关键字结束。其工作方式和 <code>=</code> 操作符一样。变量的值可以包含函数、命令、文字，或是其它变量。因为命令需要以 <code>Tab</code> 键开头， 所以如果你用 <code>define</code> 定义的命令变量中没有以 <code>Tab</code> 键开头，那么make就不会把其认为是命令。</p>
<pre><code>define miphone
echo D1
echo D2
endef
</code></pre>
<h3 id="环境变量">环境变量</h3>
<p>make运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中，但是如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖。（如果make指定了“-e”参数，那么，系统环境变量将覆盖Makefile中定义的变量）</p>
<p>因此，如果我们在环境变量中设置了 CFLAGS 环境变量，那么我们就可以在所有的Makefile中使用这个变量了。这对于我们使用统一的编译参数有比较大的好处。如果Makefile中定义了CFLAGS，那么则会使用Makefile中的这个变量，如果没有定义则使用系统环境变量的值，一个共性和个性的统一，很像“全局变量”和“局部变量”的特性。</p>
<h3 id="目标变量">目标变量</h3>
<pre><code># 目标变量为目标target设置局部变量，这种变量被称为“Target-specific Variable”
# 它可以和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。
# 而不会影响规则链以外的全局变量的值。
 &lt;target ...&gt; : &lt;variable-assignment&gt;;
 &lt;target ...&gt; : overide &lt;variable-assignment&gt;
 
# eg:
$(default_theme): PRIVATE_OUT_THEME_PATH := $(ANDROID_PRODUCT_OUT)/system/media/theme
</code></pre>
<h3 id="模式变量">模式变量</h3>
<pre><code># 模式变量为目标target给定一种“模式”，可以把变量定义在符合这种模式的所有目标上。
# 这种变量被称为(Pattern-specific Variable）。
# make的“模式”一般是至少含有一个 % 的，
# &lt;pattern ...&gt;; : &lt;variable-assignment&gt;;
# &lt;pattern ...&gt;; : override &lt;variable-assignment&gt;;
# 为所有后缀为mtz的目标设置目标变量version = 1
%.mtz : version = 1
</code></pre>
<h2 id="makefile条件判断">Makefile条件判断</h2>
<h3 id="语法-2">语法</h3>
<pre><code># 等价于 java 
# if () {
#   ...
# }
# 
# endif 结束符最近距离配对
&lt;conditional-directive&gt;
&lt;text-if-true&gt;
endif
</code></pre>
<p>或者</p>
<pre><code># 等价于 java 
# if () {
#   ...
# } else {
#   ...
# }
#
# endif 结束符最近距离配对
&lt;conditional-directive&gt;
&lt;text-if-true&gt;
else
&lt;text-if-false&gt;
endif
</code></pre>
<p>&lt;conditional-directive&gt; 指示条件有 <code>ifeq</code>、<code>ifneq</code>、<code>ifdef</code>、<code>ifndef</code> 关键字开头，指示条件不能以 <code>tab</code> 开头，指示条件后必须有空格 <code></code> 。</p>
<p>Note: make是在读取Makefile时就计算条件表达式的值，并根据条件表达式的值来选择语句， 所以，最好不要把自动化变量（如 <code>$@</code> 等）放入条件表达式中，因为自动化变量是在运行时才有的。</p>
<h3 id="示例">示例</h3>
<pre><code>mifans := true
rich = 

ifeq (true, mifans)
ifdef rich 
# buy mix2
else 
# buy red4x
endif # endif 对应 ifdef rich 
else
# can try mi phone
endif # endif 对应 ifeq (true, mifans)
</code></pre>
<h2 id="makefile函数">Makefile函数</h2>
<h3 id="语法-3">语法</h3>
<pre><code># &lt;function&gt; 函数名
# &lt;arguments&gt; 参数
# 函数名与参数之间以 &quot;空格&quot; 分割 ; 参数间以逗号 &quot;,&quot; 分割; 函数调用以 &quot;$&quot; 开头。
$(&lt;function&gt; &lt;arguments&gt;)
</code></pre>
<p>或者</p>
<pre><code>${&lt;function&gt; &lt;arguments&gt;}
</code></pre>
<h3 id="字符串处理函数">字符串处理函数</h3>
<pre><code># 字符串替换函数
$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)

# 模式字符串替换函数
$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)

# 去空格函数
$(strip &lt;string&gt;)

# 查找字符串函数
$(findstring &lt;find&gt;,&lt;in&gt;)

# 过滤函数
$(filter &lt;pattern...&gt;,&lt;text&gt;)

# 反过滤函数
$(filter-out &lt;pattern...&gt;,&lt;text&gt;)

# 排序函数
$(sort &lt;list&gt;)

# 取单词函数
$(word &lt;n&gt;,&lt;text&gt;)

# 取单词串函数
$(wordlist &lt;ss&gt;,&lt;e&gt;,&lt;text&gt;)

# 单词个数统计函数
$(words &lt;text&gt;)

# 首单词函数——firstword
$(firstword &lt;text&gt;)
</code></pre>
<h3 id="文件处理函数">文件处理函数</h3>
<pre><code># 取目录函数——dir
$(dir &lt;names...&gt;)

# 取文件函数——notdir
$(notdir &lt;names...&gt;)

# 取后缀函数——suffix。
$(suffix &lt;names...&gt;)

# 取前缀函数——basename
$(basename &lt;names...&gt;)

# 加后缀函数——addsuffix
$(addsuffix &lt;suffix&gt;,&lt;names...&gt;)

# 加前缀函数——addprefix
$(addprefix &lt;prefix&gt;,&lt;names...&gt;)

# 连接函数——join
$(join &lt;list1&gt;,&lt;list2&gt;)
</code></pre>
<h3 id="foreach-循环函数">foreach 循环函数</h3>
<pre><code># &lt;var&gt; 变量名
# &lt;list&gt; 集合，也可以是表达式
# &lt;text&gt; 使用 &lt;var&gt; 参数依赖枚举 &lt;list&gt; 中单词

# 参数 &lt;list&gt; 中的单词逐一取出放到参数 &lt;var&gt; 所指定的变量中， 然后再执行 &lt;text&gt; 所包含的表达式。
# 每一次 &lt;text&gt; 会返回一个字符串，循环过程中，&lt;text&gt; 的所返回的每个字符串会以空格分隔，最后当整个循环结束时，
# &lt;text&gt; 所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值 

$(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)

</code></pre>
<h3 id="if函数">if函数</h3>
<p>if函数很像make条件语句 <code>ifeq</code> 。</p>
<pre><code># &lt;condition&gt; 条件
# &lt;then-part&gt; 条件成立执行
$(if &lt;condition&gt;,&lt;then-part&gt;)
</code></pre>
<p>或者</p>
<pre><code># &lt;condition&gt; 条件
# &lt;then-part&gt; 条件成立执行
# &lt;else-part&gt; 条件不成立执行
$(if &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt;)
</code></pre>
<h3 id="call-函数">call 函数</h3>
<h4 id="语法-4">语法</h4>
<pre><code># call函数是唯一一个可以用来创建新的参数化的函数。
# 你可以写一个非常复杂的表达式，这个表达式中，
# 你可以定义许多参数，然后你可以call函数来向这个表达式传递参数。

$(call &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,...,&lt;parmn&gt;)
</code></pre>
<h4 id="示例-2">示例</h4>
<pre><code># 当make执行这个函数时， &lt;expression&gt; 参数中的变量，如 $(1) 、 $(2) 等，
# 会被参数 &lt;parm1&gt; 、 &lt;parm2&gt; 、 &lt;parm3&gt; 依次取代。
# 而 &lt;expression&gt; 的返回值就是 call 函数的返回值
showPhone := $(1) $(2) $(3)
result := $(call showPhone, mix2, red4x, iphoneX)
</code></pre>
<h3 id="origin函数">origin函数</h3>
<h4 id="语法-5">语法</h4>
<p>origin函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的？</p>
<p>Note:  &lt;variable&gt; 是变量的名字，不应该是引用。所以你最好不要在 &lt;variable&gt; 中使用<br>
<code>$</code> 字符。Origin函数会以其返回值来告诉你这个变量的“出生情况”，下面，是origin函数的返回值:<br>
<code>undefined</code><br>
如果 &lt;variable&gt; 从来没有定义过，origin函数返回这个值 undefined<br>
<code>default</code><br>
如果 &lt;variable&gt; 是一个默认的定义，比如“CC”这个变量，这种变量我们将在后面讲述。<br>
<code>environment</code><br>
如果 &lt;variable&gt; 是一个环境变量，并且当Makefile被执行时， -e 参数没有被打开。<br>
<code>file</code><br>
如果 &lt;variable&gt; 这个变量被定义在Makefile中。<br>
<code>command line</code><br>
如果 &lt;variable&gt; 这个变量是被命令行定义的。<br>
<code>override</code><br>
如果 &lt;variable&gt; 是被override指示符重新定义的。<br>
<code>automatic</code><br>
如果 &lt;variable&gt; 是一个命令运行中的自动化变量。关于自动化变量将在后面讲述。</p>
<pre><code>$(origin &lt;variable&gt;)
</code></pre>
<h4 id="示例-3">示例</h4>
<pre><code># 如果ICONS_PATH是环境变量
ifeq (&quot;environment&quot;, $(origin ICONS_PATH))
# do someting
endif
</code></pre>
<h3 id="shell函数">Shell函数</h3>
<p>不同于其他函数，它的参数就是操作系统Shell的命令，与反引号  `  是相同的功能。</p>
<p>Note: 这个函数会新生成一个Shell程序来执行命令，所以要注意其运行性能。</p>
<p>Note: 如果执行在 <code>commond</code> 中，会在执行前提前展开，需要使用 <code>$$</code> 才能正常执行。</p>
<pre><code># 获取当前目录下文件列表
icons := $(shell ls ./)
</code></pre>
<h3 id="控制make的函数">控制make的函数</h3>
<h4 id="语法-6">语法</h4>
<p>make提供了一些函数来控制make的运行。通常，你需要检测一些运行Makefile时的运行时信息，并且根据这些信息来决定，让make继续执行，还是停止。</p>
<pre><code>$(error &lt;text ...&gt;)
</code></pre>
<p>警告方法，只输出警告信息，然后继续执行。</p>
<pre><code>$(warning &lt;text ...&gt;)
</code></pre>
<h4 id="示例-4">示例</h4>
<pre><code>$(error &quot;is time fc !&quot;)
$(warning &quot;dir not found!&quot;)
</code></pre>
<h2 id="makefile运行">Makefile运行</h2>
<h3 id="退出码">退出码</h3>
<p>make命令执行后有三个退出码：</p>
<p>0<br>
表示成功执行。<br>
1<br>
如果make运行时出现任何错误，其返回1。<br>
2<br>
如果你使用了make的“-q”选项，并且make使得一些目标不需要更新，那么返回2。</p>
<h3 id="指定makefile">指定Makefile</h3>
<pre><code>make -f Android.mk
make --file Android.mk
make --makefile Android.mk
</code></pre>
<h3 id="指定目标">指定目标</h3>
<pre><code>.PHONY: all
all : a b
a :
    echo ---- aaaaa -----
b : 
    echo ---- bbbbb -----
</code></pre>
<p>执行输出</p>
<pre><code># 输出 ---- aaaaa -----, ---- bbbbb -----
make

# 输出 ---- aaaaa -----, ---- bbbbb -----
make all

# 输出 ---- aaaaa -----
make a

# 输出 ---- bbbbb -----
make b
</code></pre>
<h3 id="检查规则">检查规则</h3>
<p>有时候不希望makefile执行，只想检查一下命令，或是执行的序列。可以使用make命令的下述参数：</p>
<p><code>-n</code> ,  <code>--just-print</code> , <code>--dry-run</code> ,  <code>--recon</code><br>
不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，但不 执行，这些参数对于我们调试makefile很有用处。<br>
<code>-t</code> ,  <code>--touch</code><br>
这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，make假装编译目标，但不 是真正的编译目标，只是把目标变成已编译过的状态。<br>
<code>-q</code> ,  <code>--question</code><br>
这个参数的行为是找目标的意思，也就是说，如果目标存在，那么其什么也不会输出，当然也不会执行 编译，如果目标不存在，其会打印出一条出错信息。<br>
<code>-W &lt;file&gt;</code> ,  <code>--what-if=&lt;file&gt;</code> ,  <code>--assume-new=&lt;file&gt;</code> ,  <code>--new-file=&lt;file&gt;</code><br>
这个参数需要指定一个文件。一般是是源文件（或依赖文件），Make会根据规则推导来运行依赖于这个 文件的命令，一般来说，可以和“-n”参数一同使用，来查看这个依赖文件所发生的规则命令</p>
<h3 id="make的参数">make的参数</h3>
<p><code>-b, -m</code><br>
这两个参数的作用是忽略和其它版本make的兼容性。</p>
<p><code>-B, --always-make</code><br>
认为所有的目标都需要更新（重编译）。</p>
<p><code>-C &lt;dir&gt;, --directory=&lt;dir&gt;</code><br>
指定读取makefile的目录。如果有多个“-C”参数，make的解释是后面的路径以前面的作为相对路径 ，并以最后的目录作为被指定目录。如：<code>“make -C ~hchen/test -C prog”</code>等价于 <code>“make -C ~hchen/test/prog”</code>。</p>
<p><code>-debug[=&lt;options&gt;]</code><br>
输出make的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试信息。 下面是<options>的取值：</p>
<ul>
<li>a: 也就是all，输出所有的调试信息。（会非常的多）</li>
<li>b: 也就是basic，只输出简单的调试信息。即输出不需要重编译的目标。</li>
<li>v: 也就是verbose，在b选项的级别之上。输出的信息包括哪个makefile被解析，不需要被重编 译的依赖文件（或是依赖目标）等。</li>
<li>i: 也就是implicit，输出所以的隐含规则。</li>
<li>j: 也就是jobs，输出执行规则中命令的详细信息，如命令的PID、返回码等。</li>
<li>m: 也就是makefile，输出make读取makefile，更新makefile，执行makefile的信息。</li>
</ul>
<p><code>-d</code><br>
相当于“–debug=a”。</p>
<p><code>-e, --environment-overrides</code>指明环境变量的值覆盖makefile中定义的变量的值。</p>
<p><code>-f=&lt;file&gt;, --file=&lt;file&gt;, --makefile=&lt;file&gt;</code><br>
指定需要执行的makefile。</p>
<p><code>-h, --help</code><br>
显示帮助信息。</p>
<p><code>-i , --ignore-errors</code><br>
在执行时忽略所有的错误。</p>
<p><code>-I &lt;dir&gt;, --include-dir=&lt;dir&gt;</code><br>
指定一个被包含makefile的搜索目标。可以使用多个“-I”参数来指定多个目录。</p>
<p><code>-j [&lt;jobsnum&gt;], --jobs[=&lt;jobsnum&gt;]</code><br>
指同时运行命令的个数。如果没有这个参数，make运行命令时能运行多少就运行多少。如果有一个以上的“-j”参数，那么仅最后一个“-j”才是有效的。（注意这个参数在MS-DOS中是无用的）</p>
<p><code>-k, --keep-going</code><br>
出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了。</p>
<p><code>-l &lt;load&gt;, --load-average[=&lt;load&gt;], -max-load[=&lt;load&gt;]</code><br>
指定make运行命令的负载。</p>
<p><code>-n, --just-print, --dry-run, --recon</code><br>
仅输出执行过程中的命令序列，但并不执行。</p>
<p><code>-o &lt;file&gt;, --old-file=&lt;file&gt;, --assume-old=&lt;file&gt;</code><br>
不重新生成的指定的<file>，即使这个目标的依赖文件新于它。</p>
<p><code>-p, --print-data-base</code><br>
输出makefile中的所有数据，包括所有的规则和变量。这个参数会让一个简单的makefile都会输出一堆信息。如果你只是想输出信息而不想执行makefile，你可以使用<code>“make -qp”</code>命令。如果你想查看执行makefile前的预设变量和规则，你可以使用 <code>“make –p –f /dev/null”</code>。这个参数输出的 信息会包含着你的makefile文件的文件名和行号，所以，用这个参数来调试你的 makefile会是很有 用的，特别是当你的环境变量很复杂的时候。</p>
<p><code>-q, --question</code><br>
不运行命令，也不输出。仅仅是检查所指定的目标是否需要更新。如果是0则说明要更新，如果是2则说 明有错误发生。</p>
<p><code>-r, --no-builtin-rules</code><br>
禁止make使用任何隐含规则。</p>
<p><code>-R, --no-builtin-variabes</code><br>
禁止make使用任何作用于变量上的隐含规则。</p>
<p><code>-s, --silent, --quiet</code><br>
在命令运行时不输出命令的输出。</p>
<p><code>-S, --no-keep-going, --stop</code><br>
取消“-k”选项的作用。因为有些时候，make的选项是从环境变量“MAKEFLAGS”中继承下来的。所以你 可以在命令行中使用这个参数来让环境变量中的“-k”选项失效。</p>
<p><code>-t, --touch</code><br>
相当于UNIX的touch命令，只是把目标的修改日期变成最新的，也就是阻止生成目标的命令运行。</p>
<p><code>-v, --version</code><br>
输出make程序的版本、版权等关于make的信息。</p>
<p><code>-w, --print-directory</code><br>
输出运行makefile之前和之后的信息。这个参数对于跟踪嵌套式调用make时很有用。</p>
<p><code>--no-print-directory</code><br>
禁止“-w”选项。</p>
<p><code>-W &lt;file&gt;, --what-if=&lt;file&gt;, --new-file=&lt;file&gt;, --assume-file=&lt;file&gt;</code><br>
假定目标<file>;需要更新，如果和“-n”选项使用，那么这个参数会输出该目标更新时的运行动作。 如果没有“-n”那么就像运行UNIX的“touch”命令一样，使得<file>;的修改时间为当前时间。</p>
<p><code>--warn-undefined-variables</code><br>
只要make发现有未定义的变量，那么就输出警告信息。</p>
<h2 id="隐含规则">隐含规则</h2>
<p>隐含规则涵盖很多，在此之阐述模板规则和自动化变量</p>
<h3 id="模板规则">模板规则</h3>
<h4 id="规则">规则</h4>
<p>即规则的目标定义中必须包含 <code>%</code>， <code>%</code>表示长度任意的非空字符串。</p>
<pre><code>%.o : %.c ; &lt;command ......&gt;;
</code></pre>
<h4 id="示例-5">示例</h4>
<pre><code># 所有后缀为mtz依赖其名称后缀为zip文件
%.mtz : %.zip 
    # do someting
</code></pre>
<h3 id="自动化变量">自动化变量</h3>
<p><code>$@</code> : 表示规则中的目标文件集。在模式规则中，如果有多个目标，那么， <code>$@</code> 就是匹配于目标中模式定义的集合。</p>
<p><code>$%</code> : 仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是 <code>foo.a(bar.o)</code> ， 那么， <code>$%</code> 就是 <code>bar.o</code> ， <code>$@</code> 就是 <code>foo.a</code>。如果目标不是函数库文件（Unix下是 <code>.a</code> ，Windows下是 <code>.lib</code> ），那么，其值为空。</p>
<p><code>$&lt;</code> : 依赖目标中的第一个目标名字。如果依赖目标是以模式（即 <code>%</code> ）定义的，那么 <code>$&lt;</code> 将是符合模式的一系列的文件集。注意，其是一个一个取出来的。</p>
<p><code>$?</code> : 所有比目标新的依赖目标的集合。以空格分隔。</p>
<p><code>$^</code> : 所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。</p>
<p><code>$+</code>: 这个变量很像 <code>$^</code> ，也是所有依赖目标的集合。只是它不去除重复的依赖目标。</p>
<p><code>$*</code> : 这个变量表示目标模式中 <code>%</code> 及其之前的部分。如果目标是 <code>dir/a.foo.b</code> ，并且目标的模式是 <code>a.%.b</code> ，那么， <code>$*</code> 的值就是 <code>dir/a.foo</code> 。这个变量对于构造有关联的文件名是比较有效。如果目标中没有模式的定义，那么 <code>$*</code> 也就不能被推导出，但是，如果目标文件的后缀是make所识别的，那么 <code>$*</code> 就是除了后缀的那一部分。例如：如果目标是 <code>foo.c</code> ，因为 <code>.c</code> 是make所能识别的后缀名，所以， <code>$*</code> 的值就是 <code>foo</code> 。这个特性是GNU make的， 很有可能不兼容于其它版本的make，所以，你应该尽量避免使用 <code>$*</code> ，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么 <code>$*</code> 就是空值。</p>
<p>针对于以上变量可以增加 <code>D</code> <code>F</code> 字样。<br>
<code>D</code> dir  取目录部分<br>
<code>F</code>  file 取文件部分</p>
<p><code>$(@D)</code><br>
表示 <code>$@</code>的目录部分（不以斜杠作为结尾），如果 <code>$@</code> 值是 <code>dir/foo.o</code> ，那么 <code>$(@D)</code> 就是 <code>dir</code> ，而如果 <code>$@</code>中没有包含斜杠的话，其值就是 <code>.</code> （当前目录）。</p>
<p><code>$(@F)</code><br>
表示 <code>$@</code> 的文件部分，如果 <code>$@</code>值是 <code>dir/foo.o</code> ，那么 <code>$(@F)</code> 就是 <code>foo.o</code> ， <code>$(@F)</code> 相当于函数 <code>$(notdir $@)</code> 。</p>
<h2 id="后记">后记</h2>
<p>原作者：<br>
陈皓：<a href="https://coolshell.cn/haoel">https://coolshell.cn/haoel </a><br>
《跟我一起写Makefile》2004年</p>
<p>排版：<br>
miui-songhang：<a href="https://github.com/songhanghang">https://github.com/songhanghang</a></p>
<p>膜拜先辈！！！<br>
本文按 <code>代码 + 注释</code> 的思路重新整理，剔除一些章节和解释，加入一些自己的理解，如有错误，欢迎指正。</p>
<!-- 排版 MIUI-THEME-宋航 -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Goaway 远离手机]]></title>
        <id>https://songhanghang.github.io/post/goaway-yuan-chi-shou-ji</id>
        <link href="https://songhanghang.github.io/post/goaway-yuan-chi-shou-ji">
        </link>
        <updated>2018-04-05T12:09:18.000Z</updated>
        <summary type="html"><![CDATA[<p>这是一款有意思的防沉迷应用...<br>
时刻提醒消耗在手机上的时间，<br>
点亮关闭间帮你记录时间，</p>
]]></summary>
        <content type="html"><![CDATA[<p>这是一款有意思的防沉迷应用...<br>
时刻提醒消耗在手机上的时间，<br>
点亮关闭间帮你记录时间，<br>
<!-- more --><br>
底部tips告知你当前状态，<br>
五彩壁纸随着使用时间逐渐变化，<br>
长按显示各个app的使用排名，<br>
时刻警示你放下手机！</p>
<h1 id="20-下载">2.0 下载</h1>
<p><a href="https://www.coolapk.com/apk/226765">点这Download https://www.coolapk.com/apk/226765</a></p>
<h1 id="注意事项">注意事项</h1>
<ol>
<li>适配用的是miui，其他手机欢迎反馈...</li>
<li>miui为省电优化，后台默认会冻结一些能力，所以需要手动打开，<code>进入 设置-&gt;电量和性能-&gt;省电优化-&gt;应用智能省电-&gt;远离手机（该app）-&gt;点击进入后台配置-&gt;无限制</code> （该app功能简单，刷新频率低，不会耗电，欢迎监督）</li>
</ol>
<h1 id="20-更新说明">2.0 更新说明</h1>
<ul>
<li>20180311 version 3</li>
</ul>
<ol>
<li>全新首页</li>
<li>更新默认颜色及文案</li>
<li>支持全部app的使用排名展示</li>
</ol>
<ul>
<li>20180305 version 2</li>
</ul>
<ol>
<li>支持自定义提示及显示位置</li>
<li>支持自定义 Material design 背景颜色</li>
<li>支持长按壁纸显示各个app使用排名</li>
</ol>
<ul>
<li>20180302 version 1</li>
</ul>
<ol>
<li>适配小米全面屏手机</li>
<li>适配虚拟键手机</li>
<li>fix 重启手机无法显示时间提示</li>
</ol>
<h1 id="开源声明">开源声明</h1>
<p><a href="https://github.com/songhanghang/goaway">github: https://github.com/songhanghang/goaway </a><br>
感谢<a href="https://github.com/LeeReindeer">LeeReindeer同学贡献</a><br>
该app无任何恶意行为，代码在此开源，欢迎监督。<br>
如有二次开发，望加上出处，不胜感谢！</p>
<h1 id="起因">起因</h1>
<p>低头不见抬头见，</p>
<p>有了手机，</p>
<p>永不相见...</p>
<p>各种app蚕食时间，</p>
<p>不知不觉间，</p>
<p>手机又没电...</p>
<p>我想量化时间！</p>
<p>为何手机不能有防沉迷设置？</p>
<p>于是有了这个app...</p>
<h1 id="联系方式">联系方式</h1>
<p><a href="http://songhang.club">我的博客： songhang.club</a></p>
<p>邮箱: 1131442853@qq.com</p>
<p><a href="https://github.com/songhanghang">github: https://github.com/songhanghang</a><br>
<a href="https://github.com/LeeReindeer">LeeReindeer: https://github.com/LeeReindeer</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何保证ImageView.setImageResource()传入.9图片时展示正常？]]></title>
        <id>https://songhanghang.github.io/post/ru-he-bao-zheng-imageviewsetimageresourcechuan-ru-9-tu-pian-shi-zhan-shi-zheng-chang</id>
        <link href="https://songhanghang.github.io/post/ru-he-bao-zheng-imageviewsetimageresourcechuan-ru-9-tu-pian-shi-zhan-shi-zheng-chang">
        </link>
        <updated>2017-08-09T12:14:53.000Z</updated>
        <summary type="html"><![CDATA[<meta name="referrer" content="no-referrer" />
> ImageView占位图可以通过backgroud设置.9图片实现，但是在src设置成带透明alpha图片时会透视显示背景，所以用src实现占位图更合理，但是scaleType的裁剪方式同样会影响到作为src的.9图片,这将会导致.9图片不能按照预期展示占位图]]></summary>
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" />
> ImageView占位图可以通过backgroud设置.9图片实现，但是在src设置成带透明alpha图片时会透视显示背景，所以用src实现占位图更合理，但是scaleType的裁剪方式同样会影响到作为src的.9图片,这将会导致.9图片不能按照预期展示占位图
<!-- more -->
<h2 id="现象">现象</h2>
<ul>
<li>
<p>ic_launcher.9.png<br>
<img src="http://imglf0.nosdn.127.net/img/Q3dzYVVKdDlxT21CTEpLdmhuT3VzVDl6Q0RsWVdKcGlGMWNnQThGbU90OS8wSFAzd1NUWDVBPT0.jpg?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg" alt=".9图片"></p>
</li>
<li>
<p>deafault&amp;centerCrop 同样裁剪中间显示</p>
</li>
</ul>
<pre><code class="language-&lt;ImageView">        android:layout_width=&quot;200dp&quot;
        android:layout_height=&quot;200dp&quot;
        android:src=&quot;@drawable/ic_launcher&quot; /&gt;
</code></pre>
<pre><code class="language-&lt;ImageView">        android:layout_width=&quot;200dp&quot;
        android:layout_height=&quot;200dp&quot;
        android:scaleType=&quot;centerCrop&quot;
        android:src=&quot;@drawable/ic_launcher&quot; /&gt;
</code></pre>
<p><img src="http://imglf1.nosdn.127.net/img/Q3dzYVVKdDlxT21CTEpLdmhuT3VzVmloSGNFZldDOUcvMTcyeW5DUTlWS1IvREJyTGc1cWNnPT0.jpg?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg" alt="默认"></p>
<ul>
<li>fitXy显示如预期</li>
</ul>
<pre><code>    &lt;ImageView
        android:layout_width=&quot;200dp&quot;
        android:layout_height=&quot;200dp&quot;
        android:scaleType=&quot;fitXY&quot;
        android:src=&quot;@drawable/ic_launcher&quot; /&gt;

</code></pre>
<p><img src="http://imglf2.nosdn.127.net/img/Q3dzYVVKdDlxT21CTEpLdmhuT3VzVFo5eTJUZTdmTDY4U2VWb3FUTVNCUUV4MXg0L216Ykx3PT0.jpg?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg" alt="fitxy"></p>
<h2 id="问题分析-read-the-fucking-source-code">问题分析 (read the fucking source code)</h2>
<ol>
<li>mScaleType怎么参与图片裁剪逻辑？</li>
<li>图片裁剪在什么时机执行？</li>
<li>如何干预裁剪方式？</li>
</ol>
<p>第一个问题很简单ImageView.configureBounds(), 根据不同的case提供不同的换算策略，但是google用private告诉你，小子这不给你改！！！</p>
<pre><code>    private void configureBounds() {
          
            ...
        
            if (ScaleType.MATRIX == mScaleType) {
                // Use the specified matrix as-is.
                if (mMatrix.isIdentity()) {
                    mDrawMatrix = null;
                } else {
                    mDrawMatrix = mMatrix;
                }
            } else if (fits) {
                // The bitmap fits exactly, no transform needed.
                mDrawMatrix = null;
            } else if (ScaleType.CENTER == mScaleType) {
                // Center bitmap in view, no scaling.
                mDrawMatrix = mMatrix;
                mDrawMatrix.setTranslate(Math.round((vwidth - dwidth) * 0.5f),
                                         Math.round((vheight - dheight) * 0.5f));
            } else if (ScaleType.CENTER_CROP == mScaleType) {   
            ...
            } else if (ScaleType.CENTER_INSIDE == mScaleType) {
            ...
            } else {
            ...
            }
        }
    }
</code></pre>
<p>来看下第二个问题，configureBounds()都在哪调用？</p>
<ol>
<li>setImageMatrix(...)</li>
<li>updateDrawable(...) &lt;-- setImageResource(...)</li>
<li>setFrame(...)</li>
</ol>
<p>分析不难发现在绘制前这1，2两个方法并不会触发configureBounds(),所以问题指向3,setFrame的调用在View的layout(...)方法中</p>
<pre><code>public void layout(int l, int t, int r, int b) {

...
        int oldL = mLeft;
        int oldT = mTop;
        int oldB = mBottom;
        int oldR = mRight;

        boolean changed = isLayoutModeOptical(mParent) ?
                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);

...
        mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;
        mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;
    }
</code></pre>
<p>至此一和二两个问题解开迷雾，梳理下调用流程(-&gt; 下一个方法 --&gt; 方法内调用)</p>
<p>view-&gt;measure-&gt;layout--&gt;setFrame--&gt;configureBounds()-&gt;draw</p>
<p>不难分析只有在layout和draw之间动刀才可以干预裁剪方式，layout和setFrame都可以切入，根据最小作用域原则，更适合在setFrame处理.</p>
<h2 id="解决办法">解决办法</h2>
<p>自定义ImageView重写setFrame()如下</p>
<pre><code>public class NinePatchIamgeView extends ImageView {

    public NinePatchIamgeView(Context context) {
        super(context);
    }

    public NinePatchIamgeView(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
    }

    public NinePatchIamgeView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    @Override
    protected boolean setFrame(int l, int t, int r, int b) {
        // 当前ScaleType
        ScaleType curScaleType = getScaleType();
        // .9图片裁剪前设置临时类型ScaleType.FIT_XY
        if (getDrawable() instanceof NinePatchDrawable) {
            setScaleType(ScaleType.FIT_XY);
        }
        boolean changed = super.setFrame(l, t, r, b);
        // 还原ScaleType
        setScaleType(curScaleType);
        return changed;
    }
}
</code></pre>
]]></content>
    </entry>
</feed>